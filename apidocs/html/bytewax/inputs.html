<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bytewax.inputs API documentation</title>
<meta name="description" content="Helpers to let you quickly define epoch / batching semantics â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bytewax.inputs</code></h1>
</header>
<section id="section-intro">
<p>Helpers to let you quickly define epoch / batching semantics.</p>
<p>Use these to wrap an existing iterator which yields items.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Helpers to let you quickly define epoch / batching semantics.

Use these to wrap an existing iterator which yields items.

&#34;&#34;&#34;
import datetime
import heapq
from typing import Any, Callable, Iterable, Tuple


def single_batch(wrap_iter: Iterable) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;All input items are part of the same epoch.

    Use this for non-streaming-style batch processing.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, single_batch([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;a&#39;), (0, &#39;b&#39;), (0, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable of just items.

    Yields:

        Tuples of `(epoch, item)`.

    &#34;&#34;&#34;
    for item in wrap_iter:
        yield (0, item)


def tumbling_epoch(
    wrap_iter: Iterable,
    epoch_length: Any,
    time_getter: Callable[[Any], Any] = lambda _: datetime.datetime.now(),
    epoch_start_time: Any = None,
    epoch_start: int = 0,
) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;All inputs within a tumbling window are part of the same epoch.

    The time of the first item will be used as start of the 0
    epoch. Out-of-order items will cause issues as Bytewax requires
    inputs to dataflows to be in epoch order. See
    `bytewax.inputs.fully_ordered()`.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; items = [
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 3),
    ...         &#34;value&#34;: &#34;a&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 4),
    ...         &#34;value&#34;: &#34;b&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 8),
    ...         &#34;value&#34;: &#34;c&#34;,
    ...     },
    ... ]
    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.map(lambda item: item[&#34;value&#34;])
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, tumbling_epoch(
    ...     items,
    ...     datetime.timedelta(seconds=2),
    ...     lambda item: item[&#34;timestamp&#34;],
    ... ))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;a&#39;), (0, &#39;b&#39;), (2, &#39;c&#39;)]

    By default, uses &#34;ingestion time&#34; and you don&#39;t need to specify a
    way to access the timestamp in each item.

    &gt;&gt;&gt; import pytest; pytest.skip(&#34;Figure out sleep in test.&#34;)
    &gt;&gt;&gt; items = [
    ...     &#34;a&#34;, # sleep(4)
    ...     &#34;b&#34;, # sleep(1)
    ...     &#34;c&#34;,
    ... ]
    &gt;&gt;&gt; list(tumbling_epoch(items, datetime.timedelta(seconds=2)))
    [(0, &#39;a&#39;), (2, &#39;b&#39;), (2, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable of just items.

        epoch_length: Length of each epoch window.

        time_getter: Function that returns a timestamp given an
            item. Defaults to current wall time.

        epoch_start_time: The timestamp that should correspond to
            the start of the 0th epoch. Otherwise defaults to the time
            found on the first item.
        
        epoch_start: The integer value to start counting epochs from.
            This can be used for continuity during processing.

    Yields:

        Tuples of `(epoch, item)`.

    &#34;&#34;&#34;
    for item in wrap_iter:
        time = time_getter(item)

        if epoch_start_time is None:
            epoch_start_time = time
            epoch = epoch_start
        else:
            epoch = int((time - epoch_start_time) / epoch_length) + epoch_start

        yield (epoch, item)


def fully_ordered(wrap_iter: Iterable) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;Each input item increments the epoch.

    Be careful using this in high-volume streams with many workers, as
    the worker overhead goes up with finely granulated epochs.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, fully_ordered([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable of just items.

    Yields:

        Tuples of `(epoch, item)`.

    &#34;&#34;&#34;
    epoch = 0
    for item in wrap_iter:
        yield (epoch, item)
        epoch += 1


def sorted_window(
    wrap_iter: Iterable,
    window_length: Any,
    time_getter: Callable[[Any], Any],
    on_drop: Callable[[Any], None] = None,
) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;Sort a iterator to be increasing by some timestamp.

    To support a possibly infinite iterator, store a limited sorted
    buffer of items and only emit things downstream once a certain
    window of time has passed, as indicated by the timestamp on new
    items.

    New input items which are older than those already emitted will be
    dropped to maintain sorted output.

    The window length needs to be tuned for how &#34;out of order&#34; your
    input data is and how much data you&#39;re willing to drop: Already
    perfectly ordered input data can have a window of &#34;0&#34; and nothing
    will be dropped. Completely reversed input data needs a window
    that is the difference between the oldest and youngest timestamp
    to ensure nothing will be dropped.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; items = [
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 4),
    ...         &#34;value&#34;: &#34;c&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 3),
    ...         &#34;value&#34;: &#34;b&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 0),
    ...         &#34;value&#34;: &#34;a&#34;,
    ...     },
    ... ]
    &gt;&gt;&gt; sorted_items = list(
    ...     sorted_window(
    ...         items,
    ...         datetime.timedelta(seconds=2),
    ...         lambda item: item[&#34;timestamp&#34;],
    ...     )
    ... )
    &gt;&gt;&gt; sorted_items
    [{&#39;timestamp&#39;: datetime.datetime(2022, 2, 22, 1, 2, 3), &#39;value&#39;: &#39;b&#39;},
    {&#39;timestamp&#39;: datetime.datetime(2022, 2, 22, 1, 2, 4), &#39;value&#39;: &#39;c&#39;}]

    You could imagine using it with `tumbling_epoch()` to ensure you
    get in-order, bucketed data into your dataflow.

    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.map(lambda item: item[&#34;value&#34;])
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, tumbling_epoch(
    ...     sorted_items,
    ...     datetime.timedelta(seconds=0.5),
    ...     lambda item: item[&#34;timestamp&#34;],
    ... ))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;b&#39;), (2, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable.

        window_length: Buffering duration. Values will be emitted once
            this amount of time has passed.

        time_getter: Function to call to produce a timestamp for each
            value.

        on_drop: Function to call with each dropped item. E.g. log or
            increment metrics on drop events to refine your window
            length.

    Yields:

        Values in increasing timestamp order.

    &#34;&#34;&#34;
    sorted_buffer = []
    newest_time = None
    drop_older_than = None

    def is_too_late(time):
        return drop_older_than is not None and time &lt;= drop_older_than

    def is_newest_item(time):
        return newest_time is None or time &gt; newest_time

    def emit_all(emit_older_than):
        while len(sorted_buffer) &gt; 0 and sorted_buffer[0][0] &lt;= emit_older_than:
            time, item = heapq.heappop(sorted_buffer)
            yield item

    for item in wrap_iter:
        time = time_getter(item)

        if is_too_late(time):
            if on_drop:
                on_drop(item)
        else:
            heapq.heappush(sorted_buffer, (time, item))

            if is_newest_item(time):
                newest_time = time
                drop_older_than = time - window_length

                yield from emit_all(drop_older_than)

    yield from emit_all(newest_time)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bytewax.inputs.fully_ordered"><code class="name flex">
<span>def <span class="ident">fully_ordered</span></span>(<span>wrap_iter:Â Iterable) â€‘>Â Iterable[Tuple[int,Â Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Each input item increments the epoch.</p>
<p>Be careful using this in high-volume streams with many workers, as
the worker overhead goes up with finely granulated epochs.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from bytewax import Dataflow, run
&gt;&gt;&gt; flow = Dataflow()
&gt;&gt;&gt; flow.capture()
&gt;&gt;&gt; out = run(flow, fully_ordered([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
&gt;&gt;&gt; sorted(out)
[(0, 'a'), (1, 'b'), (2, 'c')]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrap_iter</code></strong></dt>
<dd>Existing input iterable of just items.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>Tuples of <code>(epoch, item)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fully_ordered(wrap_iter: Iterable) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;Each input item increments the epoch.

    Be careful using this in high-volume streams with many workers, as
    the worker overhead goes up with finely granulated epochs.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, fully_ordered([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable of just items.

    Yields:

        Tuples of `(epoch, item)`.

    &#34;&#34;&#34;
    epoch = 0
    for item in wrap_iter:
        yield (epoch, item)
        epoch += 1</code></pre>
</details>
</dd>
<dt id="bytewax.inputs.single_batch"><code class="name flex">
<span>def <span class="ident">single_batch</span></span>(<span>wrap_iter:Â Iterable) â€‘>Â Iterable[Tuple[int,Â Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>All input items are part of the same epoch.</p>
<p>Use this for non-streaming-style batch processing.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from bytewax import Dataflow, run
&gt;&gt;&gt; flow = Dataflow()
&gt;&gt;&gt; flow.capture()
&gt;&gt;&gt; out = run(flow, single_batch([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
&gt;&gt;&gt; sorted(out)
[(0, 'a'), (0, 'b'), (0, 'c')]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrap_iter</code></strong></dt>
<dd>Existing input iterable of just items.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>Tuples of <code>(epoch, item)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_batch(wrap_iter: Iterable) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;All input items are part of the same epoch.

    Use this for non-streaming-style batch processing.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, single_batch([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;a&#39;), (0, &#39;b&#39;), (0, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable of just items.

    Yields:

        Tuples of `(epoch, item)`.

    &#34;&#34;&#34;
    for item in wrap_iter:
        yield (0, item)</code></pre>
</details>
</dd>
<dt id="bytewax.inputs.sorted_window"><code class="name flex">
<span>def <span class="ident">sorted_window</span></span>(<span>wrap_iter:Â Iterable, window_length:Â Any, time_getter:Â Callable[[Any],Â Any], on_drop:Â Callable[[Any],Â None]Â =Â None) â€‘>Â Iterable[Tuple[int,Â Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Sort a iterator to be increasing by some timestamp.</p>
<p>To support a possibly infinite iterator, store a limited sorted
buffer of items and only emit things downstream once a certain
window of time has passed, as indicated by the timestamp on new
items.</p>
<p>New input items which are older than those already emitted will be
dropped to maintain sorted output.</p>
<p>The window length needs to be tuned for how "out of order" your
input data is and how much data you're willing to drop: Already
perfectly ordered input data can have a window of "0" and nothing
will be dropped. Completely reversed input data needs a window
that is the difference between the oldest and youngest timestamp
to ensure nothing will be dropped.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from bytewax import Dataflow, run
&gt;&gt;&gt; items = [
...     {
...         &quot;timestamp&quot;: datetime.datetime(2022, 2, 22, 1, 2, 4),
...         &quot;value&quot;: &quot;c&quot;,
...     },
...     {
...         &quot;timestamp&quot;: datetime.datetime(2022, 2, 22, 1, 2, 3),
...         &quot;value&quot;: &quot;b&quot;,
...     },
...     {
...         &quot;timestamp&quot;: datetime.datetime(2022, 2, 22, 1, 2, 0),
...         &quot;value&quot;: &quot;a&quot;,
...     },
... ]
&gt;&gt;&gt; sorted_items = list(
...     sorted_window(
...         items,
...         datetime.timedelta(seconds=2),
...         lambda item: item[&quot;timestamp&quot;],
...     )
... )
&gt;&gt;&gt; sorted_items
[{'timestamp': datetime.datetime(2022, 2, 22, 1, 2, 3), 'value': 'b'},
{'timestamp': datetime.datetime(2022, 2, 22, 1, 2, 4), 'value': 'c'}]
</code></pre>
<p>You could imagine using it with <code><a title="bytewax.inputs.tumbling_epoch" href="#bytewax.inputs.tumbling_epoch">tumbling_epoch()</a></code> to ensure you
get in-order, bucketed data into your dataflow.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flow = Dataflow()
&gt;&gt;&gt; flow.map(lambda item: item[&quot;value&quot;])
&gt;&gt;&gt; flow.capture()
&gt;&gt;&gt; out = run(flow, tumbling_epoch(
...     sorted_items,
...     datetime.timedelta(seconds=0.5),
...     lambda item: item[&quot;timestamp&quot;],
... ))
&gt;&gt;&gt; sorted(out)
[(0, 'b'), (2, 'c')]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrap_iter</code></strong></dt>
<dd>Existing input iterable.</dd>
<dt><strong><code>window_length</code></strong></dt>
<dd>Buffering duration. Values will be emitted once
this amount of time has passed.</dd>
<dt><strong><code>time_getter</code></strong></dt>
<dd>Function to call to produce a timestamp for each
value.</dd>
<dt><strong><code>on_drop</code></strong></dt>
<dd>Function to call with each dropped item. E.g. log or
increment metrics on drop events to refine your window
length.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>Values in increasing timestamp order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorted_window(
    wrap_iter: Iterable,
    window_length: Any,
    time_getter: Callable[[Any], Any],
    on_drop: Callable[[Any], None] = None,
) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;Sort a iterator to be increasing by some timestamp.

    To support a possibly infinite iterator, store a limited sorted
    buffer of items and only emit things downstream once a certain
    window of time has passed, as indicated by the timestamp on new
    items.

    New input items which are older than those already emitted will be
    dropped to maintain sorted output.

    The window length needs to be tuned for how &#34;out of order&#34; your
    input data is and how much data you&#39;re willing to drop: Already
    perfectly ordered input data can have a window of &#34;0&#34; and nothing
    will be dropped. Completely reversed input data needs a window
    that is the difference between the oldest and youngest timestamp
    to ensure nothing will be dropped.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; items = [
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 4),
    ...         &#34;value&#34;: &#34;c&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 3),
    ...         &#34;value&#34;: &#34;b&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 0),
    ...         &#34;value&#34;: &#34;a&#34;,
    ...     },
    ... ]
    &gt;&gt;&gt; sorted_items = list(
    ...     sorted_window(
    ...         items,
    ...         datetime.timedelta(seconds=2),
    ...         lambda item: item[&#34;timestamp&#34;],
    ...     )
    ... )
    &gt;&gt;&gt; sorted_items
    [{&#39;timestamp&#39;: datetime.datetime(2022, 2, 22, 1, 2, 3), &#39;value&#39;: &#39;b&#39;},
    {&#39;timestamp&#39;: datetime.datetime(2022, 2, 22, 1, 2, 4), &#39;value&#39;: &#39;c&#39;}]

    You could imagine using it with `tumbling_epoch()` to ensure you
    get in-order, bucketed data into your dataflow.

    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.map(lambda item: item[&#34;value&#34;])
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, tumbling_epoch(
    ...     sorted_items,
    ...     datetime.timedelta(seconds=0.5),
    ...     lambda item: item[&#34;timestamp&#34;],
    ... ))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;b&#39;), (2, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable.

        window_length: Buffering duration. Values will be emitted once
            this amount of time has passed.

        time_getter: Function to call to produce a timestamp for each
            value.

        on_drop: Function to call with each dropped item. E.g. log or
            increment metrics on drop events to refine your window
            length.

    Yields:

        Values in increasing timestamp order.

    &#34;&#34;&#34;
    sorted_buffer = []
    newest_time = None
    drop_older_than = None

    def is_too_late(time):
        return drop_older_than is not None and time &lt;= drop_older_than

    def is_newest_item(time):
        return newest_time is None or time &gt; newest_time

    def emit_all(emit_older_than):
        while len(sorted_buffer) &gt; 0 and sorted_buffer[0][0] &lt;= emit_older_than:
            time, item = heapq.heappop(sorted_buffer)
            yield item

    for item in wrap_iter:
        time = time_getter(item)

        if is_too_late(time):
            if on_drop:
                on_drop(item)
        else:
            heapq.heappush(sorted_buffer, (time, item))

            if is_newest_item(time):
                newest_time = time
                drop_older_than = time - window_length

                yield from emit_all(drop_older_than)

    yield from emit_all(newest_time)</code></pre>
</details>
</dd>
<dt id="bytewax.inputs.tumbling_epoch"><code class="name flex">
<span>def <span class="ident">tumbling_epoch</span></span>(<span>wrap_iter:Â Iterable, epoch_length:Â Any, time_getter:Â Callable[[Any],Â Any]Â =Â &lt;function &lt;lambda&gt;&gt;, epoch_start_time:Â AnyÂ =Â None, epoch_start:Â intÂ =Â 0) â€‘>Â Iterable[Tuple[int,Â Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>All inputs within a tumbling window are part of the same epoch.</p>
<p>The time of the first item will be used as start of the 0
epoch. Out-of-order items will cause issues as Bytewax requires
inputs to dataflows to be in epoch order. See
<code><a title="bytewax.inputs.fully_ordered" href="#bytewax.inputs.fully_ordered">fully_ordered()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from bytewax import Dataflow, run
&gt;&gt;&gt; items = [
...     {
...         &quot;timestamp&quot;: datetime.datetime(2022, 2, 22, 1, 2, 3),
...         &quot;value&quot;: &quot;a&quot;,
...     },
...     {
...         &quot;timestamp&quot;: datetime.datetime(2022, 2, 22, 1, 2, 4),
...         &quot;value&quot;: &quot;b&quot;,
...     },
...     {
...         &quot;timestamp&quot;: datetime.datetime(2022, 2, 22, 1, 2, 8),
...         &quot;value&quot;: &quot;c&quot;,
...     },
... ]
&gt;&gt;&gt; flow = Dataflow()
&gt;&gt;&gt; flow.map(lambda item: item[&quot;value&quot;])
&gt;&gt;&gt; flow.capture()
&gt;&gt;&gt; out = run(flow, tumbling_epoch(
...     items,
...     datetime.timedelta(seconds=2),
...     lambda item: item[&quot;timestamp&quot;],
... ))
&gt;&gt;&gt; sorted(out)
[(0, 'a'), (0, 'b'), (2, 'c')]
</code></pre>
<p>By default, uses "ingestion time" and you don't need to specify a
way to access the timestamp in each item.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pytest; pytest.skip(&quot;Figure out sleep in test.&quot;)
&gt;&gt;&gt; items = [
...     &quot;a&quot;, # sleep(4)
...     &quot;b&quot;, # sleep(1)
...     &quot;c&quot;,
... ]
&gt;&gt;&gt; list(tumbling_epoch(items, datetime.timedelta(seconds=2)))
[(0, 'a'), (2, 'b'), (2, 'c')]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrap_iter</code></strong></dt>
<dd>Existing input iterable of just items.</dd>
<dt><strong><code>epoch_length</code></strong></dt>
<dd>Length of each epoch window.</dd>
<dt><strong><code>time_getter</code></strong></dt>
<dd>Function that returns a timestamp given an
item. Defaults to current wall time.</dd>
<dt><strong><code>epoch_start_time</code></strong></dt>
<dd>The timestamp that should correspond to
the start of the 0th epoch. Otherwise defaults to the time
found on the first item.</dd>
<dt><strong><code>epoch_start</code></strong></dt>
<dd>The integer value to start counting epochs from.
This can be used for continuity during processing.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>Tuples of <code>(epoch, item)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tumbling_epoch(
    wrap_iter: Iterable,
    epoch_length: Any,
    time_getter: Callable[[Any], Any] = lambda _: datetime.datetime.now(),
    epoch_start_time: Any = None,
    epoch_start: int = 0,
) -&gt; Iterable[Tuple[int, Any]]:
    &#34;&#34;&#34;All inputs within a tumbling window are part of the same epoch.

    The time of the first item will be used as start of the 0
    epoch. Out-of-order items will cause issues as Bytewax requires
    inputs to dataflows to be in epoch order. See
    `bytewax.inputs.fully_ordered()`.

    &gt;&gt;&gt; from bytewax import Dataflow, run
    &gt;&gt;&gt; items = [
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 3),
    ...         &#34;value&#34;: &#34;a&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 4),
    ...         &#34;value&#34;: &#34;b&#34;,
    ...     },
    ...     {
    ...         &#34;timestamp&#34;: datetime.datetime(2022, 2, 22, 1, 2, 8),
    ...         &#34;value&#34;: &#34;c&#34;,
    ...     },
    ... ]
    &gt;&gt;&gt; flow = Dataflow()
    &gt;&gt;&gt; flow.map(lambda item: item[&#34;value&#34;])
    &gt;&gt;&gt; flow.capture()
    &gt;&gt;&gt; out = run(flow, tumbling_epoch(
    ...     items,
    ...     datetime.timedelta(seconds=2),
    ...     lambda item: item[&#34;timestamp&#34;],
    ... ))
    &gt;&gt;&gt; sorted(out)
    [(0, &#39;a&#39;), (0, &#39;b&#39;), (2, &#39;c&#39;)]

    By default, uses &#34;ingestion time&#34; and you don&#39;t need to specify a
    way to access the timestamp in each item.

    &gt;&gt;&gt; import pytest; pytest.skip(&#34;Figure out sleep in test.&#34;)
    &gt;&gt;&gt; items = [
    ...     &#34;a&#34;, # sleep(4)
    ...     &#34;b&#34;, # sleep(1)
    ...     &#34;c&#34;,
    ... ]
    &gt;&gt;&gt; list(tumbling_epoch(items, datetime.timedelta(seconds=2)))
    [(0, &#39;a&#39;), (2, &#39;b&#39;), (2, &#39;c&#39;)]

    Args:

        wrap_iter: Existing input iterable of just items.

        epoch_length: Length of each epoch window.

        time_getter: Function that returns a timestamp given an
            item. Defaults to current wall time.

        epoch_start_time: The timestamp that should correspond to
            the start of the 0th epoch. Otherwise defaults to the time
            found on the first item.
        
        epoch_start: The integer value to start counting epochs from.
            This can be used for continuity during processing.

    Yields:

        Tuples of `(epoch, item)`.

    &#34;&#34;&#34;
    for item in wrap_iter:
        time = time_getter(item)

        if epoch_start_time is None:
            epoch_start_time = time
            epoch = epoch_start
        else:
            epoch = int((time - epoch_start_time) / epoch_length) + epoch_start

        yield (epoch, item)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bytewax" href="index.html">bytewax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bytewax.inputs.fully_ordered" href="#bytewax.inputs.fully_ordered">fully_ordered</a></code></li>
<li><code><a title="bytewax.inputs.single_batch" href="#bytewax.inputs.single_batch">single_batch</a></code></li>
<li><code><a title="bytewax.inputs.sorted_window" href="#bytewax.inputs.sorted_window">sorted_window</a></code></li>
<li><code><a title="bytewax.inputs.tumbling_epoch" href="#bytewax.inputs.tumbling_epoch">tumbling_epoch</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>